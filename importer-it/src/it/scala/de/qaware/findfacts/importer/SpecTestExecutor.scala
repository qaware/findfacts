package de.qaware.findfacts.importer

import scala.jdk.CollectionConverters._
import scala.collection.immutable.IndexedSeq
import scala.collection.mutable.ListBuffer
import scala.reflect.runtime.universe._
import scala.reflect.runtime.{currentMirror, universe}
import scala.tools.reflect.ToolBox

import better.files.{File, Resource}
import de.qaware.findfacts.common.dt.CodeblockEt
import de.qaware.findfacts.common.solr.LocalSolr
import de.qaware.findfacts.common.solr.mapper.FromSolrDoc
import de.qaware.findfacts.importer.SpecTestExecutor.SESSION
import de.qaware.findfacts.scala.Using
import io.github.classgraph.ClassGraph
import org.apache.solr.client.solrj.SolrQuery
import org.scalatest.Suite
import org.scalatest.funsuite.AnyFunSuite
import org.scalatest.matchers.should.Matchers

/**
 * Context for spec tests.
 *
 * @param name of the spec test
 * @param block created from Isabelle import
 * @param src Isabelle theory source code
 * @param startLine at which Isabelle theory source code starts
 */
case class SpecTestContext(name: String, block: CodeblockEt, src: String, startLine: Int)

/** Parent test suite, that builds a nested suite for each Spec-theory. */
class SpecTestExecutor extends AnyFunSuite with Matchers {

  test("Solr core present") {
    Using.resource(LocalSolr(File(Resource.getUrl("solrdir/")).toJava)) { solr =>
      val indexes = solr.listIndexes
      indexes should have size 1
    }
  }

  override lazy val nestedSuites: IndexedSeq[Suite] = {
    // Discover theory spec files
    val thyFiles = Using.resource(new ClassGraph().acceptPathsNonRecursive("").scan) { scan =>
      scan.getResourcesWithExtension(".thy").getPaths.asScala.toIndexedSeq
    }

    // Setup JIT compiler
    val toolbox = currentMirror.mkToolBox()

    // Get imported entities
    val query = new SolrQuery("{!parent which=doc_kind:Parent}")
      .setFields("*", "[child parentFilter=doc_kind:Parent limit=-1]")
      .setRows(Int.MaxValue)
    val mapper = FromSolrDoc[CodeblockEt]
    val blocks = Using.resource(LocalSolr(File(Resource.getUrl("solrdir/")).toJava)) { solr =>
      solr.query(query).getResults.asScala.map(mapper.fromSolrDoc(_).get).toList
    }

    // Build test suite for each file
    thyFiles.map { file =>
      buildTestsuite(file, blocks.filter(_.theory == s"$SESSION.${File(file).nameWithoutExtension}"), toolbox)
    }
  }

  /**
   * Builds a test suite from a theory spec file.
   *
   * @param thyFile Isabelle thy file with SPEC tests
   * @param blocks code blocks generated by the import of the Isabelle theory
   * @param toolbox for JIT compilation
   * @return Compiled test suite
   */
  private def buildTestsuite(thyFile: String, blocks: List[CodeblockEt], toolbox: ToolBox[universe.type]): Suite = {
    val specSuiteName = s"SpecTest $thyFile"

    // Read spec tests from theory file
    val file = Resource.getAsString(thyFile)

    // Try to parse 'SPEC' format
    val testSpecs = SpecTestParser.parse(file) match {
      case Left(error) =>
        return new AnyFunSuite() {
          override val suiteName: String = specSuiteName
          test(s"Check spec file")(fail(error))
        }
      case Right(value) => value
    }

    // Try to join spec and block
    val blockByLine = blocks.map(b => b.startLine -> b).toMap
    val contexts = ListBuffer.empty[SpecTestContext]
    val testCaseAsts = ListBuffer.empty[Tree]
    testSpecs.foreach(spec =>
      blockByLine.get(spec.specStartLine + 1) match {
        case Some(block) =>
          testCaseAsts += buildTest(contexts.size, spec, toolbox)
          contexts += SpecTestContext(spec.name, block, spec.thyCode, spec.specStartLine + 1)
        case None =>
          testCaseAsts += q"""test("Find block for spec \"" + ${spec.name} + "\"")(fail("Could not find block"))"""
      })

    // Build test suite creator (function that takes all the contexts and makes them available in the testsuite)
    val buildTestSuiteAst =
      q"""(contexts: List[de.qaware.findfacts.importer.SpecTestContext]) =>
          new org.scalatest.funsuite.AnyFunSuite with org.scalatest.matchers.should.Matchers {
            import de.qaware.findfacts.common.dt._

            val blocks = contexts.map(_.block)

            override val suiteName = $specSuiteName
             ..${testCaseAsts.toList}
          }
       """

    // Compile and run
    try {
      val buildTestSuite = toolbox.eval(buildTestSuiteAst).asInstanceOf[List[SpecTestContext] => AnyFunSuite]
      buildTestSuite(contexts.toList)
    } catch {
      case e: Throwable =>
        new AnyFunSuite() {
          override val suiteName: String = specSuiteName
          test("Compile tests")(fail(e.getMessage))
        }
    }
  }

  /**
   * Build a single test abstract syntax tree for a given theory spec.
   *
   * @param idx of the context for the test
   * @param spec of the text
   * @param toolbox for JIT compilation
   * @return AST of test method call
   */
  private def buildTest(idx: Int, spec: Spec, toolbox: ToolBox[universe.type]): Tree = {
    val testName = "SPEC test \"" + spec.name + "\""

    // Try to parse test function, including test code
    try {
      val tests = toolbox.parse(s"{${spec.testCode}}")
      // In the test function, provide some context and then add tests
      q"""test($testName) {
            val ctx = contexts($idx)

            val block = ctx.block
            val command = block.command
            val entities = block.entities
            val constants = entities.collect { case t: ConstantEt => t }
            val facts = entities.collect { case f: FactEt => f }
            val types = entities.collect { case t: TypeEt => t }

            $tests
          }
       """
    } catch {
      case e: Throwable =>
        try {
          q"""test($testName){fail("Could not parse test spec: " + ${e.getMessage})}"""
        } catch {
          case e: Throwable =>
            println(e.toString)
            throw e
        }
    }
  }
}

/** Companion object. */
object SpecTestExecutor {

  /** Isabelle session name. */
  final val SESSION = "Spec-Tests"
}
